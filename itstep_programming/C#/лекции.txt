using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
class students
{
    string name, surname, lastname;
    int group, age;
    int[][] rating = new int[3][];
    public students(string _name, string _surname, string _lastname, int _group, int _age)
    {
        name = _name; surname = _surname; lastname = _lastname; group = _group; age = _age;
        Random N = new Random();
        for (int i = 0; i < 3; i++)
        {
            int r = N.Next(20) + 1;
            rating[i] = new int[r];
            for (int j = 0; j < r; j++)
            {
                rating[i][j] = N.Next(11);
            }
        }
    }
    public void setmark(int a, int subj) // a- ocenka
    {
        int k = rating[subj].Length;
        int[] temp = new int[k];
        for (int i = 0; i < k; i++)
        {
            temp[i] = rating[subj][i];  //скопировали строку(оценки предмета)
        }
        rating[subj] = new int[k + 1];
        for (int i = 0; i < k; i++)
        {
            rating[subj][i] = temp[i];
        }
        rating[subj][k] = a;
    }
    public void printsubj()
    {
        Console.WriteLine("1) программирование\n2) администрирование\n3) дизайн\nвыберите предмет:");
        int number;
        //Console.WriteLine(number);

        if (!int.TryParse(Console.ReadLine(), out number))
        {
            Console.WriteLine();
            Console.ReadLine();
        }
        foreach (int i in rating[number - 1])
        {
            Console.Write(i + " ");
        }
        // Console.WriteLine("{0} {1} {2} {3}",name,surname,lastname,age;....
    }

}
namespace ArrayFunctions
{
    class Program
    {

        static void Main(string[] args)
        {
            students first = new students("BYGA-BYGA", "ICE", "AGE", 03, 1300);
            first.setmark(10, 2);
            first.printsubj();
        }
    }
}
  С# язык со строгой типизацией 
  Ссылочные и значимые:
  1) Значимые в стеке
  Простые типы данных
  Структуры
  Перечисления
  2) Ссылочные в куче =)
  Классы
  интерфейсы
  Массивы, строки, делегаты;
  
  
  Типы:
  Целочисленные, дробные, логические(булл)
  Целочисленные:
  sbyte, byte (1 байт памяти) {-128; 127}
  short, Ushort(2 байта) {-32768; 32767}
  Int, Uint (4 байта) {SsssS}
  Long, Ulong; (8 byte's)
  char ((sybol type) 2 bytes (Unicode +));
  
  
  Дробные:
  float (7 после запятой)
  double (15-16 после запятой)
  decimal (28-29 после запятой)
  
  Логические:  Bool (1 byte);
  -------------------------------------------
  
  ЛИТЕРАЛЫ
  Это фиксированное значение, которое представленно в понятной форме, или по другому - константное значение.
  Все литералы имеют тип
  Для отнесения литерала к определенному типу - определено неск. правил:
   1)  Для целочисленного литерала назначается наименьший целый тип, позв. его хранить.
   2)  Все дробные значения имеют тип даббл
   3)  Для явной спецификации типа предусмотрен спец символ - L, F, D, M, U;
   L - Long
   F - Float
   D - double
   M - Decimal
   U - Unsigned
   
          
  В отдельную группу литераллов выделена последовательность (Escape) ((символьная последовательность)) \a
  
  Строковые литералы - выражаются в двойных ковычках
  для того, что бы строка воспринимаалась буквально(упр символы не работали) - перед стр. константой ставится значок @.
  
  
  
  ПЕРЕМЕННЫЕ:
  
  !!!!!!!!!!!!!!!!!! 
  
  Не явно типизированные типы: 
       var x = 7;, var y = 8.5, var z = 8.3F;
       Не явно тип. переменная задается var и должна быть сразу проинициализированна );
          нельзя явно преобразовать логический тип в явный, и наоборот -)
          нет авто-преобразования символьного типа в целый.
          
  
  
  ________Рандомчикиииии______________
       класс рандом Random(std:: System), который для вычисления нач. числа последовательности случ. числел
       использует системное время
       Random r = new Random;
       r.Next(); 0  RandMax;
  
  
       Массивы
       
   ТИП[размер] имя = new ТИП[размер];
   массив в Сишарп является ссылочным типом данных. те размещается в дин. памяти
   Размерность массива может задаваться переменной.
   ! псоле выделения памяти все элементы массива обнуляются автоматически.
   Размерность массива должна совпадать с колвом элементов в массиве.
                           int[] Arr = new int[256];
                           
       char[,] arr = new char[2,3];
       
           Рваные массивы;
  int[][] arr = new int [3][];
  arr[0] = new int[4]{1,2,3,4};
  arr[1] = new int[2]{0,1};
  
  
               1   2   3   0
               0   2
               0   0   0
  если двумерный массив можно предсттавить ввиде таблицы - то рваный массив можно определить как массив, строки которого могут иметь различную длинну
  рваные массивы объявляются с помощью двух кв.скобок.
  доступ к елементу рваного массива осущ. через указание индекса строки м столбца в кв. скобках!_)
   Выход за пределы массива, или обращение к несуществующему элементу приводит к ошибоньке
   Компилятор такие ошибки не отслеживает (
   
  
       особенности работы с массивами
           Тк массив С# Ссылочный, то он представлен объектом класса Array
       1. Свойство Length возвращает кол-во элементов, которое способен хранить массив.
           for(int i=0; i<arr.length; i++) {};
           В двумерном возвращается кол-во всех массивов;
           |Length для рваного массива возвращает колво строка, а при обращении к каждой строке возвращает кол-во элементов в строке.
       2. Присовение массивов друг другу:
           При копировании одного массива в другой - онми будут ссылаться на один участок памяти.
           Для поверхностного копирования массивов юзается метода clone (copy);
           Clone создает новый массив, а COPY требует наличие сущ массива той же размерности
           
  
  
  
           foreach(тип, ит.начала, ит.конец){
           Тип итератора должен совпадатьс типом элемента в коллекции
           }
  
           МОЖНО ТТОКА ВЫВЕСТИ ЭЛЕМЕНТА МАССИВА, ИЗМЕНИТЬ ИХ НЕЛЬЗЯ(
           для многомерных массивов все элементы выводятся линейно.
  
  
           Строки в шарпе представленны классом String и являются ссылочными или объектными
           
           Создание строк
           
           strint str1 = "Простая строка";
           char[] ctr1 = {'A', 'B',...};
           string str2 = new string(ctr1);
           string str3 = new string(ctr, 8, 6);
           string str4 = new string('$', 10);
           
           2. ToString();
           int x = 7;
           string s = x.ToString();
           
  
  
  
           РАБОТА СО СТРОКАМИ
           1. Длина строки определяется свойством Length. Вернется кол-во символов
           2. К каждому символу можно обратиться по индексу
           3. Через индекс нельзя изменить символ строки
           4. Строки типа стринг не изменны.
           5. Для объединения строк используется символ "+"
           6. Строки юзаются в конструкции switch
           7. строки могут быть объеденены в Массив =)
           8. Для стравнения строк исп оператор = или !=, и проверяет равенство содержжимого двух строк
           9. Основные методы для работы со строками:

/*26.02.2015 4лекция
 * строки тип StringBuilder
   StringBuilder такую строку изменить можно, не создавая дополнительной копии но мало возможностей. можно преобразовывать строки в строки stringbuilder и наоборот
     В отличие от строк типо string , строки типа stringbuilder являються изменяемыми но имеют меньшее количество возможностей по работе со строками
     Строки типа string при создании выделяют столько памяти сколько необходимо для хранения строки
     Строки типа stringbuilder выделяют изначально память в 16символов а если строка хангимает больше места то размер удваиваеться
 * для создания строки тпа stringbuilder используют следующий синтаксис:
     StringBuilder hello = new StringBuilder("...",емкость строки);
 * строка типа StringBuilder имею два свойства: Length() и Capacity() емкость
     Length() показывает длину строки находящуюся  в данный момент
     Capacity() максимальная длина строки которая может поместиться в выделенную для обьекта память
     По умолчанию для пустой строки емкость устанавливаеться в 16символов
 * Основные методы класса StringBuilder: 
    .Append() добовляет строку к текущей строке
    .AppendFormat() добовляет форматированную строку к текущей строке
    .Insert() вставляет подстроку в строку
    .Remove() удаляет символ из текущей строки
    .Replace()
    .ToString() строку типа StringBuilder можно перевести в строку типа string      sring s=str.ToString()
 * 
 * 
 * 
 * #Классы
     инкапсуляция 
     полиморфизм
     наследование
    [<атрибуты>][<спецификаторы>] class <имя класса>
    { 
        тело класса
    }
    
    class UserInfo
    {
    поля класса
    public string Name, Family, Adress;
    public byte Age;
    
     метод, выводящий в консоль контактную информацию
    public void writeInConsoleInfo(string name,string faamily,string adress,byte age)
    {
    Console.WriteLine("имя: {0}\nФамилия: {1}\nМестонахождение: {2}\nВозраст:{3}\n", name, family, adress, age);
    }
    
    * Object
    при копировании переменных происходит перенос значений а при копировании обьектов они будут укзазывать на одну и ту же область памяти;
    UserInfo myInfo = new UserInfo();
        //  строки данных: значимые и ссылочные
    
         != инициализаторы обьектов
    инициализаторы обьектов предоставляют способ создания обьектоа и инициализации его полей и свойств
    используеться вызов обычного конструктора
    auto myCar = new autoCar { marka = "Renault", year = 2004 };
    
     * Поля(данные члены)
    все поля в классе инициализируете нулями
    поля класса - переменные описанные в классе
    по умолчанию переменные класса считаються закрытыми (private)
    [<атрибуты>][<спецификаторы>] <тип> <имя> [=<начальное значение>];
    
    * Методы(функции члены)
    Если метод ничего не возвращает то тип возвращаемого значение void и return не пишеться
    спецификаторы
    В предеах одного класса сигнатуры методов не должны повторяться
    Фактическиен параметры являються локальными по отношению к методу и уничтожаються после выхода из метода
    спецификаторы: модификаторы доступа, virtual,sealed,static,ovveride, ,extern
    Передача аргументов в метод по ссылке и по значению:
        при классической передаче аргументов метод используеться передача по значению, тоесть переданные аргументы копируються и становяться локальными по отношению к методам.Если из метода необходимо вернуть более одного значения то в такой метод необходимо передовать аргументы по ссылке.Для передачи по ссылке используеться два модификатора ref и out. Модификатор ref и out Должны указываться как при передаче аргументом так и в списке параметров метода
        вызов F(ref x);
        метод F(out int x);
        переменные передаваемые в метод с модификатором ref должны быть обязательно проинициализированы до передачи.
        переменные с модификатором out могут не иметь инициализации, но внутри метода должны быть обязательно проинициализированы
        В методе параметр out считаеться непроинициализированным
    Модификатор Params
        ключевое слово params позволяет передавать методу переменное количество аргументов одного типа ввиде единственного логического параметра
        В качестве аргумента в метод с модицификтором params может быть передан как отдельный массив, так и множество ОДНОТИПНЫХ элементов перечисленных через запятую
        Если метод принимает несколько параметров одним из которых являеться параметр с _parasm то параметр с _params должен идти в списке параметров последним
        В списке параметров метода может присутствовать только один модификатор с параметров params 
        int [] mas
        вызов 1: F(mas);
              2: F(11,2,3,9);
        обьявление: F(params int[]mas){
        }
______________________________________________________________________________________ 
 
 02.03.2015
    * Необязательные и именованные аргументы
    Необязательные аргументы необходимы для того чтобы использовать по умолчанию значения для некоторых параметров метода.Необязательные аргументы указываються в конце списка параметров через знак равно и присвоение значения по умолчаию.
    static int mySum(int a,int b=5,int c=10)
 * {
 * ....
 * }
 * ....
 * int sum=mySum(a,5)
     Именованные аргументы предназначены для передачи в метод в любой последовательности. При передаче необходимо указать имя параметра, двоеточие и его значение.
 * int sum=mySum(c:3,a:3,b:3)
 
    Конструктор
    Конструктор это метод класса предназначенный для инициализации обьекта при созданиикоторый имеет такое же имя как имя класса ничего не возвращает может принимать неограниченное число параметров. Чаще всего используеться со спецификатором доступа public
    Каждый класс снабжаеться конструктором по умолчанию, тоесть без параметра.Такое конструктор можно переопределить
    Point obj=new Point();
  !! При создании конструктора с параметрами конструктор без параметров(который по умолчанию) затираеться поэтому при создании пользовательских типо необходимо пересоздавать конструктор без параметров
 
    Финализатор(деструктор)
    деструктор это метод который вызываеться автоматическим сборщиком мусора перед удалением обьекта из памяти. Деструктор имеет такое же имя как и имя класса ничего не возрващает и ничего не принимает,перед ним используеться знак ~.
    
    This ключевое слово
    Обеспечивает доступ к текущему обьекту. 
    Использование this: 1) для решения неоднозначности контекста    2) Сцепление конструкторов  Сцепление конструкторов используеться когда имееться класс определяющий несколько конструкторов и в каждом из конструкторов необходимо делать однотипные проверки на инициализацию полей, поэтому для предотвращения избыточной проверки один конструктор может вызывать другой. очередность вызова конструктора в цепочке:
        K1(параметр):this(пар1,пар2){тело K1;}   
        K2(пар1,пар2){тело K2;}
    
    1)Статические элементы класса поля и методы
    статический элемент класса используеться на уровне класса независимо от обьектов этого класса. статические элементы класса обьявляються с помощью ключевого слова static.
    статические поля(типо глобальные пля)    все обьекты класса совместно используют статическую переменную. Для доступа к статической переменной Имя_класса.Имя_переменной .
    Class Planet
    {
    private static int Count;
    public Planet()
        {
        Count++;
        }
    }
    2)статические методы 
    используються на уровне класса и вызываються через имя класса.  статические методы могут обращаться только к статическим переменным и методам данного класса.
    в статическом методе не может использоваться ссылка this.   
    3) статические конструкторы
    статический конструктор используеться для инициализации компонентов применяемых ко всему классу. Статический конструктор вызываеться автоматически при первом обращении к имени класса.
    4) статические классы
    статический класс должен содержать только статические члены. обьект статического класса создать нельзя. статические классы используються в основном для хранения совокупности связанных друг с другом статических методов.
    
  * Частичные типы
    Если необходимо разбить класс на разные файлы в рамках одного пространства имен то перед слово класс пишеться слово partial.
     public partial class NAME{}

 !тема    * Исключительные ситуации
    SystemException     ApplicationException
    try{
    <operator1>
    ...
    }
    catch([<тип исключения> [<имя>]]) {
        <operator1>
    ....
    };
    finally
    {
    <operator1>
    ...
    }
    Исключительные ситуации в С# представлен классом exception и его производными. каждый класс описывает конкретную исключительную ситуацию. 
    В блок finally помещаеться код который будет выполнен вне зависимости от того была ли сгенерирована исключительная ситуация.
    Чаще используеться для освобождения различных ресурсов. порядок обработки исключений:
    1) вход в блок try
    2) если исключительная ситуация не возникла то переход к блоку finally а если его нет то переходи к инструкции следующим за последним блоком catch.
    3) если ситуация возникла в блоке try то пееход к соответствующему блоку catch. если в catch нету выхода из метода то далее переход к инструкции после всех блоков catch (либо к finally).
    4) при наличии блока finally его выполнение и переход к инструкции после finally а далее к инструкции после блока finally.
        Исключения могут быть сгенерированы внутри метода который был вызван из блока try. 
        если после блока try используеться несколько блоков catch то каждый отдельный блок должен выполнять обработку определенной исключительной ситуации. блок catch должен иметь определенный тип исключения. блок catch без параметров являеться универсальным и срабатывает для всех типов ошибок и ставиться последним, так как поиск соответствующего блока обработки осуществляеться по очередно.
     
        ! вложенные блоки try и catch.  
            Один try блок можно вложить в другой. Исключения сгенерированное во ввнутреннем try блоке и не перехваченное внутренним catch блоком передаеться во внещний try блок. Вложенность try блоков чаще всего используеться для обработки различных категорий ошибок. во внутреннем блоке помещяються менее опасные, во внешнем - более опасные.
    
03.03.2015  
    Генерирование исключений вручную
    throw - инструкция используеться для того тчобы сгенерировать исключения вручную. После слова throw указываем ключе слово new который создает обьект определенный исключительной ситуации
    try{
        console.write("..");
        throw new FormatException();
    }
    catch(FormatException){
    ...
    }
        class SomException:Exception
        {   public override string Message
            {   get
                {
                    return "some exception";
                }
            }
        }
    Для создания собственных исключений необходимо создать новый класс унаследовать его от класса exception и необходимо переопределить соответствующие свойства и методы. Для генерации пользовательского исключения пользуемся throw
    
    Повторное генерирование исключений:
    Исключения перехваченное одной catch инструкцией можно перегенерировать чтобы обеспечить возможность его перехвата другой внешней catch инструкцией. для этого используеться слово throw без параметра. При повторном генерировании исключения оно не будет повторно перехватываться той же catch инструкцией а передаеться следующей catch инструкции. //выходим на внешний блок try-catch
    
    Свойства и методы классов исключительной ситуации.
    Console.Writeline("свойство message" +exc.Message);
    exc.Message -выводит строку с описанием причины ошибки
    exc.StackTrace -выводит строку со стеком вызоввов приведших к возникновении исключения
    exc.TargetSite -возвращает имя метода сгенерировавшее исключение
   !! для использования данных своств необходимо в параметре блока catch указывать в параметре блока catch имя исключения но и имя обьекта
    
  Применение конструкции checked и unchecked
    эти блоки используються для генерации исключения при возникновении переполнения. эти инструкции исподьзуються в двух формах:
    1) checked(выражение)
       unchecked(выражение)
    2) checked{
            инструкции.}
        unchecked {}
    
        byte a=127,b=127,result;
        try{
            result=checked((byte)(a*b));
            ConsoleWriteLine(result);}
        catch{
            console.writeline(exc.Message);}
    
   Пространство имен
        пространство имен это некая область обьявления данных, которая обеспечивает логическую взимосвязь типов.
        1) пространства имен могут быть вложены в друг друга. в таком случае для доступа к внутреннему классу необходимо перечислить всеп имена пространст имен начиная с внешнего черех точку.
        2) в рамках одного проекта может существовать несколько пространств имен.
        если в одном файле существует два пространства имен то области их видимости не пересекаються, для того чтобы обратиться из одного пространства имен к элементам второго пространства имен необходимо писать полный путь к элементам.
        если два простраства имен куазанные в операторах using содержат тип с одинаковым именем, то необходимо использовать полную форму имени.
       Одно простраство имен может быть разбито на части в рамках одного файла.
       using может применяться не только для подключения простраства имен но и для создания псевдонимов пространства имен.
        using A=AAA;                ///namespace AAA{ }
            A::Incrementor
        
        
04.03.2015
Тема перегрузка операторов
     требования к перегрузке операторов:
        1) перегрузка операторов позволяет указать как стандартный оператор будет использоваться с обьектами класса.
        2) перегрузка операторов должна выполняться ОТКРЫТЫМИ public СТАТИЧЕСКИМИ метода класса
        3) параметры перегружаемого метода не должны включать модификаторы out и ref
        4) у перегружаемого метода тип возврщаемого значения или тип одного из параметров должен совпадать с типом в котором выполняеться перегрузка
        5) невозможно изменить значение стандарных операций для стандартных типов данных
        нельзя использовать this
        
     ограничения на перегрузку:
        1) перегрузка не может изменять приоритет операторов
        2) перегрузка не может изменять количество операндов, с которым работает перегружаемый оператор
        3) операторы не допускающие перегрузку: =, +=, -=, *= , =, >>=, ., ?:, new , as,is,typeof,->,sizeof       
     
     синтаксис перегрузки оператора:
        public static тип_возвр.знач operator символ_операции (список параметров)
        
  Перегрузка..->
        -> унарных операторов:+ ++ -- -
            public static тип_возврата operator op(тип_ параметра операнд1){...}
            тип операнда должен совпадать с классом, для которого определен оператор
            перезрузка постфиксной и префиксной форм операторов отдельно не выделяються или не выполянються
            оператор - не должен изменять состояние текущего обьекта, а должен возвращать новый обьект

        -> бинарных операторов:
            public static тип_возвр operator op(тип_параметра1 операнд1, тип_параметра2 операнд2){...}
            хотябы один из тип операндов должен совпадать с классом, для которого опредлен оператор
            при приминении бинарных операций для обьекта и встроенного типаданных важен порядок следования операндов
        
        -> операторы отношений: < >, >= <=, == !=  операторы отношений перегружаються парами
            оператор отношения возвращает логический тип True or False
        
        -> перегрузку операторов True False. -надо перегружать в паре
        
        -> перегрузка логических операторов: &, |, ! (побитовые операции)
            должны возвращать bool
            для перегрузки сокращенных логических операторов && || необходимо учесть дополнительные перегрузки
            Для перегрузки логических операторов работающих по сокращенной схеме необходимо 
                    1)перегрузить побитовые операторы & и |
                    2)перегруженные операторы должны возвращать обьект класса для которого перегружаються эти операторы
                    3)каждый параметр должен быть ссылкой на обьект класса
                    4)также необходимо перегрузить операторы true и false
        
        -> перегрузка операторов преобразования
                /явное преобразование (когда данные могут быть утеряны)
                public static excplicit operator тип_результата (исходный_тип v)
                {return значение;}
                
                /автоматич (когда не теряем данные)
                public static implicit operator тип_результата (исходный_тип v)
                {return значение;}
            В одном классе нельзя одновременно делать перегрузку явного и неявного преобразования


--/--/-- ->Свойства и индексаторы:
                               Свойства предназначены для организации доступа к закрытым полям класса.
                               Заменяют открытые методы
                               могут иметь accessors set & get, в каждом из которых осуществляются проверки присвоения и возвращения результатов переменной
                               для которой было созданно свойство.
                               private int size;
                               public int size{
                                   get{return size};
                                   set{size = value};
                                   }
                               Особенности работы со свойствами:
                               
                               1. Свойства могут содержать только один accessors: get || set || get & set;
                               2. Свойство не может быть перегруженно.
                               3. Не может быть переданно в  метод с параметром ref или out;
                               4. Свойство не должно изменять значение переменной в <get>
                               5. Свойства могут быть статическими.
                               6. Один из аксцессоров доступа может иметь различные спецификаторы доступа. Второй акц должен обязательно иметь спец-р доступа соответствующий свойст
                               Автоматические свойства:
                               для полей класса можно создавать автьматические свойства, т.е. записывать акц гет и сэт без тела.
                               1. Поддерживающие переменные создаются автоматически
                               2. Проверка достоверности вводимых данных в методе set не может быть выполнена.
                               3. Должны присутствовать оба метода доступа.
                                
                               
  
                               Сокрытие членов производных от базового класса
                               base - обращение к сокрытым членам класса.
                                   Сокрытие имен при наследовании: 
                                       Производный класс может определить член, имя которого совпадает с именем базового класса.
                                       В этом случае член базового класса становится скрытым в производном классе.
                                       Данная ситуация не вызовет ошибки, а только предупреждение, для предотвращения которого необходимо указать ключевое слово new перед членом производного класса.
                                       Скрывать модно не только переменные, но и методы, свойства, и т.д.
                                       для доступа к скрытым элементам базового класса из производных используется слово "base."
                                   Использование ссылок базового класса на приозводном:
                                   Объект одного класса не может быть присвоен объекту другого класса, за искл. того, если они находятся в иерархии наследования
                                   ССЛЫКИ БАЗОВОГО КЛАССА МОЖНО ПРИСВОИТЬ ОБЪЕКТ ЛЮБОГО ПРОИЗВОДНОГО КЛАССА.
                                   class X{
                                       int a;
                                       }
                                   class Y:X{
                                       int b;
                                       X x1 = new y();
                                       x1.a =3;
                                       x1.b = 4; //error
                                       }
                                           
                                   Тип ссылочной переменной, а не тип объекта, на который она ссылается - определяет какие члены могут быть доступны.
                                   Чаще всего ссыллки типа "базовый класс на производный" используютс при создании универсальных методов, которые принимают ссылки базового класса, а передоватьв них можно
                                   объекты производных классов
                                   Виртуальные методы:
                                   Виртуальным называется метод который объявляется с помощью virtual в базовом классе, и переопределяется в одном или неск. производных классов с помощью override.
                                   виртуальные методы имеют смысл, когда они вызываются через ссылку на базовый класс
                                   !!!!ТИП ОБЪЕКТА, НА КОТОРЫЙ УКАЗЫВАЕТ ССЫЛКА, (А НЕ ТИП ССЫЛКИ) ОПРЕДЕЛЯЕТ, КАКАЯ ВЕРСИЯ ВИРУТАЛЬНОГО МЕТОДА БУДЕТ ВЫПОЛНЕНА
                                   ПРИ ПЕРЕОПРЕДЕЛЕНИИ ВИРУТАЛЬНОГО МЕТОДА СИГНАТУРЫ ВИРТУАЛЬНОГО И ПЕРЕОПРЕДЕЛЕННОГО ДОЛЖНЫ СОВПАДАТЬ.
                                   ЕГО НЕльзя определять, как статический.
                                   переопределение виртуальных методов является основой динамической диспетчерезацией методов\
                                   Это мех-м вызова переопределенного метода во время выполнения программы (а не в переиод компиляции)
                                   виртуальными могут быть и свойства.
                                   Если виртуальный метод переопределяет виртуальный метод в многоуровневой иерархии - то будет выполнен первый переопределенный метод, 
                                   который обнаружится при просмотре иерархической лестнице снизу вверх.



	10.03.2015
	....(-1/2)
	конструкторы и наследование
	конструкторы не наследуютсья поэтому производный класс должен иметь собственные конструкторы().
        base(...)
	конструктор.пк(пар-ры):
	base(пар-ры){тело констр.П.К}
	3. ВЫПОЛНЕНИЕ тела конструктора базового класса
	4. возврат к телу производного класса и его ВЫПолнение

	Если в иерархии наследования стоит больше двух классов, то вызов конструкторов осуществляеться от производного через базовыу к самому общему базовому классу, а выполнение наоборот

	использование ключевого слова base:
	1.вызов конструктора базового класса
		с помощью base я тот конструктор параметры которого соответствуют переданным аргументам в base
		!!! base всегда отсылает базовому классу стоящему в иерархии классов непосредственно над вызывающим классом. если слово base отсутствует то автоматически вызываеться конструктор базового класса по умолчанию.
	2.Для доступа к члену базового класса который скрыт за членом производного класса
    
    
    
    
11.03.2015
    base
    2. для доступа к члену базового класса который скрыт за членом производного 
    
    Сокрытие имен при наследовании:
    +производный класс может определить член имя которого совпадает с именем члена базового класса. в этом случае член базового класса становиться скрытым в производном классе
    +дання ситуация не вызовет ошибки компиляции а ттолько предупреждение, для предотвращения которого необходимо указать клюевое слово new перед членом производного класса
    +скрывать можно не только переменные но и методы и свойства
    +для доступа к скрытым элементам базового класса из производного используеться слово base.
    
ТЕМА    Использование ссылок базового класса на производный
    +Обьек одного класса не может быть присвоен обьекту другого класса за исключением того если они находяться в иерархии наследования
        ССЫЛКИ БАЗОВОГО КЛАССА МОЖНО ПРИСВОИТЬ ОБЬЕКТ ЛЮБОГО ПРОИЗВОДНОГО КЛАССА
    class X{int a;}
    class Y:X{int b;}
    X x1=new Y();       // можем обратиться только к базовому классу x1.area();
    X1.a=3;
    //X1.b=4; //ERROR!!!
    Тип ссылочной переменной а не тип обьекта на который она ссылаеться определяет какие члены могут быть доступны
    Чаще всего ссылки типа базовый класс на производный используеть для создания универсальных методов, которые принимают ссылки базового класса, а передавать в них можно обьекты производных классов
    virtual+override
        Виртуальные методы
    Виртуальным называеться метод который обьявляеться с помощью ключевого слова virtual в базовом классе и переопределяеться в одном или нескольких производных классах с помощью ключевого слова override
    Виртуальные методы имеют смысл когда ни вызывваютсья через ссылку на базовый класс.
!   тип обьекта на который указывает ссылка, а не тип ссылки, определяет какая версия виртуального метода будет выполнена. При переопределении вирутального метода сигнатуры виртуального и метода переопределенного должны совпадать.
    виртуальный метод нельзя переопределять как статический
    Переопределение(override) виртуальных методов являеться основой динамической диспетчиризации методов(это механизм вызова переорпеделенного метода во время выполнения программы а не в период компиляции)
    Виртуальный метод переопределять необязательно. Если переопределения в производном классе нет то будет вызван виртуальный мтеод ближайшего базового класса.
    Помимо методов виртуальными могут быть и свойства.
    Если производный класс не переопределяет виртуальный метод в случае многоуровневой иерархии то будет выполнен первый переорпеделенный метод который обнаружиться в присмотре иерархической лесницы снизу-вверх

 * Модификатор abstract в объявлении класса указывает, что класс предназначен только для использования в качестве базового класса для других классов.



12.03.2015
АБСТРАКТНЫЕ КЛАССЫ И МЕТОДЫ
    иногда виртуальный метод в базовом классе не может иметь реализацию. В таком случае вместо виртуальных методов используються абстрактные. Абстрактный метод обьявляеться с помощью ключевого слова abstract не имеет тела и в конце заголовка ставиться ;
    Если виртуальный метод может быть непереопределен в производном классе, то абстрактный метод должен быть обязательно переопределен в производном классе с помощью ключевого слова override.
    Абстрактный метод есть виртуальный поэтому совместное использование слов virtual и abstract недопустимо. Абстрактные методы не могут быть статическими.
    Если в классе определен хотябы 1 абстрактный метод, то такой класс отмечаеться как abstract. Обьекты абстрактного класса создавать нельзя. Если абстрактный метод всеже непереопределен в производном классе то такой класс также должен быть помечен как абстрактный. Абстрактными могут быть не только методы, но и свойства.
        Обьект абстрактного класса создавать нельзя, но можно создать ссылку типа абстрактный класс, которая будет указывать на обьекты производных классов.

    sealed использование ключевое слово (sealed - герметезированый)
    используеться перед именем класса для того чтобы пеедотвратить наследование от него.
   так же sealed позволяет запечатывать переопределенные методы.

Правило приведеня к базовому и производному классу:
    1.-> Когда 2 класса связаны отношением наследованием(являеться) всегда можно бехопасно сохранить обьект производного класса в ссылке базового класса.(это называеться неявным приведением)
    в .NET конечным базовым классом являеться класс Object и все созданные классы неявно наследуються от Object, следовательно обьект любого класса можно сохиранить в ссылке типа object.
    2.-> Необходимо явно выполнять приведение вниз, тоесть от более общего к более частному используя операцию приведение (класс_к_кот.приводим)обьект_кот_приводим).

    Явное приведение используеться:
        -> для доступа к членам класса при обращении через ссылку базовоого класса
            Shape S=new Tr();
            ((Tr)S).style="   ";
        -> при передаче в метод ссылки базового класса на производный, если метод принимает обьект производного класса
           object T3=new Triangle();
            public static void show(TwoDShape s)
            {            }
    явное приведение происходит во время выполнения а не во время компиляции программы, следовательно существует вероятность неправильного приведения типов. Для проверки на правильность приведения используеться три варианта
        а) включить в блок try строку с явным приведением. try{Triangle T3=(Director)T2;}//error
        б) использование ключевого слова as. Операция as возвращает либо ссылка на новый приведенный обьект либо NULL если типы не приводяться. Director T1=new Director(); Triangle T1=D1 as Triangle; if(T1==null)...
        в) использование ключевого слова is. Операция возвращает true если типы совместимы, false если несовместимы. if(D1 is Triangle) (Triangle)D1.some=...; else ...

*КЛАСС Object
    object [] m=new object[10];
    object[0]=1;
    object[1]='a';
    object[2]="string";
    так как object базовый класс для всех типов языка C# то его можно использовать в качестве обобщенного типа данных(можно создавать массив типа object и хранить там любые значения)

    упаковка m[3]=true
    ссылка типа object может указывать на значимую переменную, тоесть происходит перенос значений переменной из стека в кучу. такой процесс называеться Упаковкой или boxing;
    привидение к обьектному типу осуществляеться автоматически.
        int x; //   значимый тип
        object obj; //  ссссылочный тип (в куче)
        obj=x; //   boxing;

    Обратный процесс восстановления значимого типа из обьектного называеться распоковкой unboxing. Реализуеться через явное приведение к значимому типу.
    itn y=(int)mas[0];
    Класс object используеться при описании типа параметров методов для придания им общност, а также для хранения ссылок на обьекты различного типа, таким образом реализуеться полиморфизм.
  Класс object имеет следующие открытые методы:
    -> .Equals() - сравнивает обьект для которого вызван метод с параметром на принадлежность к одной и тойже области памяти. виртуальнй метод значит его можно переопределить.
    -> .GetHashCode() - формирует хэшкод обьекта и возвращает число однозначно иденцифицирующее обьект. виртуальный метод значит его можно переопределить. // int
    -> .GetType() - возвращает тип обьекта  на который указывает ссылка.
    -> .ToString() - виртуальный метод который для ссылочных типов возвращает имя класса ввиде строки, а для значимых значения ввиде строки.
    -> .ReferenceEquals() - статический метод возвращает true если оба параметра ссылаються на одну и туже область памяти.


16.03.2015
Интерфейсы
    
    class A:ISome
    interface ISome
    {
        методы
        свойства int this[int,]{get;set;}
        индексаторы
        события
    }

    [<атрибуты>] [<спецификаторы>] interface имя_интерфейся [:<предки>]
    Интерффейс позволяет определить , ЧТО класс должен делать, а не КАК он это будет делать
    Класс может наследовать наследовать неограниченное число интерфейсов. У интерфейся может быть неограниченное число предков.
    В списке предков класса сначала указывает его базовый класс если он есть, а затем интерфейся, которые реализует данный класс

    В интерфейсе не могут содержатсья поля, конструкторы, поля, деструкторы, операторные методы.
    В интерфейсе все элементы неявно являються открытыми.
    не разрешаеться явным образом задавать спецификаторы доступа для элементов интерфейса
    Для методов внутри интерфейса указываеть только тип возрв.значения, имя члена и список параметров
    Ни1 член интерфейса не может быть статическим.
    
    Реализация интерфейса:
    при наследовании интерфейса после : указываеться имя базового класса и далее через запятую имена всех интерфейсов предков
    сигнатуры методов в интерфейсе и в классе с реализацией должны совпадать.
    методы реализованные в классе из интерфейса должны быть открытыми.
    В классе помимо методов реализованных из интерфесов можно создавать дополнительные члены.
    Члены интерфейса реализованные в классе могут создаваться виртуальными или абстрактными но не статическимии или константными.
    При реализации интерфейса перед реализуемым членом можно указать имя интерфейса. В таком случае метод становиться закрытым и доступ к нему будет осуществлятсья через привидение.
    
!    Если класс реализует интерфейс унаследованный от другого интерфейса, то в классе должны быть реализованы методы двух интерфейсов.
    
    Интерфейсные ссылки:
    нельзя создать обьект интерфеса но можно создать ссылку на класс
     * http://stackoverflow.com/questions/17576/non-public-members-for-c-sharp-interfaces
    Точно также, как можно создавать ссылки типа базовый класс и указывать их на производные, можно создавать интерфейсные ссылки, которые будут указывать на обьекты классов реализующих данный интерфейс.
!   нельзя создавать обьекты интерфейсов
    Интерфейсная ссылка предназначена для обращения к методам реализованным из интерфейса.
    Для обращения к собственным полям и мтеодам класса нужно будет делать явное привидение.
    При вызове метода через интерфейсную ссылку бкудет выполнен тот метод на обьект которого в данный момент указывает интерфейсая ссылка.
    
    Предположим что создан массив типа Shape который содержит обьекты производных классав причем некоторые обьекты поддерживают интерфейс IPoint а некоторые неподдерживают.Для определения  во время работы программы поддреживает ли обьект интерфейс используеться несколько способов: 
    1. явное привидение обьекта к интерфейсу и заключение этой операции в блок try
    -> 2. использование ключевого слова as 
    3. использование ключевого слова is
    
    Использование интерфейсов в качестве параметров:
    МЕТОДЫ МОГУТ ПРИНИМАТЬ ИНТЕРФЕЙСНЫЕ ССЫЛКИ, что позволяет передавать в такие методы обьекты различных типов несвязанные между собой кроме как интерфейсом
    Интерфейсные ссылки можно не только передавать в методы но и возвращать из методов.
    При наследовании класса от нескольких интерфейсов существует вероятность совпадения имен методов в этих интерфейсах.В таком случае в классе название реализуемого мтеода необхходимо предварять именем интерфейса с точкой. Указывать модификатор доступа для такогореализуемого элемента не требуеться, так как авт он приватный. Следовательно доступ к такому члену будет осуществляться через явное привидение обьекта класса соответствующего интерфейсной ссылки.
    интерфейс IComparable,IEnumerable,IComparer,IClonable
*/

СТРУКТУРЫ


	Особенности структур:
	1.	Структура является значимым типом данных, следовательно, при присвоении переменной типа структура другой переменной – будет происходить полное копирование элементов структуры. Также при передаче элемента структуры в метод измененное значение структуры не будет сохранено после метода(функции).
	2.	Переменную типа структура можно создавать с помощью кл.слова new, которое в отличии от классов, память не выделяет, а запускает конструктор для инициализации полей полей структуры. New использовать не обязательно.
	3.	Структура может содержать перегруженный конструктор, за исключением переопределения конструктора по умолчанию. КПУ(Конструкторы по умолчанию инициализирует поля нулями)
	4.	Инициализация полей внутри структуры запрещена.
	5.	Структуры не поддерживают наследование от структур, а только от ИФ, следовательно protected не используется.
	6.	Нельзя создавать виртуальные/абстрактные методы.
	7.	Статические элементы в структуре допускается.
	8.	Структуры не явно унаследованные от класса System.ValueType (System.Object) -> следовательно структуре доступны методы этих классов.



ПЕРЕЧИСЛЕНИЯ

	Это не пустой список именованных констант, который задает все значения, которые сможет принимать все значения данного типа.
	System.Enum

	enum Days {Monday, Saturday, Sunday};
	Значение должно быть целочисленное(default – INT). Значения автоматически назначаются с нуля, и каждое последующее больше предыдущего со сдвигом на единицу




							ДЕЛЕГАТЫ

	1.	Делегат(delegate) – это объект, который может ссылаться на метод.
	2.	Во время выполнения программы один и тот же делегат можно использовать для вызова различных методовЮ просто заменив метод, на который ссылается этот делегат.
	3.	Делегат может вызывать только такие методы, у которых тип возвращаемого значения и список параметров совпадает с соответствующими элементами объявления делегатов.
	4.	Делегат может вызвать либо метод экземпляра класса, или статический  метод, связанный с классом.
	5.	Все делегаты представляют собой классы, которые неявным образом выводятся из класса System.Delegate


	Многоадресная передача – это способность создавать список вызов 9или цепочку вызовов) методов, которые должны автоматически вызываться при вызове делегата.

	Для этого необходимо:
	1)	Создать экземпляр делегата
	2)	Для добавления методов в цепочку использовать оператор «+=»
	3)	Для удаления метода из цепочки использовать оператор «-=»
	!!! ДОЛЖЕН ВОЗВРАЩАТЬ ТИП VOID  ГЫ-ГЫ


	Передача делегата в метод:
	\	delegate int De1(string S);
	Public int Func(string S){
	Return int.Parse(s);}

	Public void Method(int x, De1){
	String s = “25”;
	x = d1(s);

	main(){
	int x =0;
	method (x, new De1(func));}



	События:
	1.	Событие – это автоматические уведомление о выполнении некоторого действия.
	2.	Объект, которому необходимо информация о некотором событии,  регистрирует обработчик




	1.	Создаем событие делегат
	Delegate void MyEventHandler();
	2.	 Создаем событие, связанное 
	Public event MyEventHandler SomeEvent;
	3.	Создаем метод для искуственного вызова события
	public void OnSomeEvent(){
	if(SomeEvent != null){ 		//У  события должен быть обработчик
		SomeEvent();}		//Активизация или вызов события



	4.	Класс для метода-обработчика события. Их может быть много оч оч.
	Class EventDemo{
	5.	//метод-обработчик должен иметь одинаковый список 
	static void handler(){
	Console.WriteLine(“Handler occurred”);}


	что бы управлять списоком обработчиков событий, можно использовать вторую форму Event-инструкции, которая содержит два акцессора – add и remove, которые вызываются в случае добавления или удаления обработчика. 


КОЛЛЕКЦИИ

	Существует пять видов коллекций:
	1.	Необобщенные – структуры данных,  обобщенного назначения, оперирующие ссылками на объекты.

	2.	Обобщенные – являются типизированными, в них можно хранить только те типы, которые совместимы по типу с ее аргументом.
	System.Collections.Generic

	3.	Специализированные – оперируют данными конкретного типа.
	System.Collections.Specialized

	4.	По-разрядная – Поддерживает операции над отдельными двоичными разрядами.
	System.Collections.BitArray

	5.	Параллельные коллекции поддерживают параллельный доступ к такой коллекции
	System.Collections.Concurrent



23.03.2015

		Обобщения(generic)
	обобщение - параметризированный тип.
	Обобщения позволяют создавать классы, структуры, интерфейсы, методы и делегаты в которых ОБРАБАТЫВАЕМЫЕ ДАННЫЕ УКАЗЫВАЮТЬСЯ В ВИДЕ ПАРАМЕТРА.

	преимущества использования обобщений:
	+ производительность
	+ безопасность
	+ повторное использование двоичного кода

	Обобщенные классы
	многие алгоритмы не зависят от типов данных с которыми они работают(сортировка или поиск). следовательно удопбно для класса контейнера указывать тип данных для которого этот контейнер бужет использоваться.Параметры типов используеться lzk указания следующих типов: 1) переменных или полей класса 2) параметров функций 3) возвращение значений из функции  4) локальных переменных

	Ограничение обобщений применимы к обобщенным методам, классам,интерфейсам,структурам,методам.	Указываються после ключевого слова where
	where T: struct
	where T: class
	where T: Icompatible
	where T: BaseClass
	where T: new() тип Т должен иметь конструктор по умолчанию
	where T: T2 тип Т наследуеться от обобщенного типа Т2. такое ограничение известно как ограничение "голого" типа

	Особенности ограничений:
	ограничение на базовый класс позволяет указывать базовый класс, который должен наследоваться аргументом типа.
	для любого огрничения, накладываемого на базовый класс, аргумент типа должен обозначать САМ БАЗОВЫЙ КЛАСС ИЛИ ПРОИЗВОДНЫЙ ОТ НЕГО КЛАСС.
	where T: имя_базового_класса
!!!!!   Одновременно в этой форме ограничения может быть указан только оди базовый класс

	Ограничение на интерфейс позволяет указывать интерфейс, который должен быть  реализован аргументом типа
	where T: new
	Если ограничение накладываеться одновременно на базовый класс и интерфейс, то первый в списке должен быть указан базовый класс.
	
	Ограничение на конструктор
	where T: new()
	ограничение new()
	1) можно использовать вместе с другими ограничениями, но последним по порядку.
	2) позволяет конструировать обьект, используя только конструктор без параметров, - даже если доступны другие конструкторы. Иными словами, передавать аргументы конструктору параметтра типа не разрешаеться.
	3) НЕЛЬЗЯ ИСПОЛЬЗОВАТЬ ОДНОВРЕМЕННО С ОГРАНИЧЕНИЕМ ТИПА ЗНАЧЕНИЯ

	ограничения ссылочного {0}типа и типа {1}значения указываються первыми по порядку {0} {1}// образно

	Обобщенные классы могут стоять в иерархии наследования.
!!!     В ПРОИЗВОДНОМ КЛАССЕ СЛЕДУЕТ УКАЗЫВАТЬ ПАРАМЕТРЫ ТИПА, ТРЕБУЮЩИЕСЯ ЕГО ОБОБЩЕННОМУ БАЗОВОМУ КЛАССВУ, ДАЖЕ ЕСЛИ ЭТОТ ПРОИЗВОДНЫЙ КЛАСС НЕОБЯЗАТЕЛЬНО ДОЛЖЕН БЫТЬ ОБОБЩЕННЫМ
	ОБОБЩЕННЫЙ КЛАСС МОЖНО УНАСЛЕДОВАТЬ ОТ НЕОБОБЩЕННОГО.

	Средства обобщения:ЕСЛИ переменной типа Т внутри обобщенного класса требуеться присвоить значение по умолчанию, то используеться коснтруктор default(T); 
//quizful.net professorweb.ru

курсор в классе и нажать F12