using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
class students
{
    string name, surname, lastname;
    int group,age;
    int [][]rating=new int[3][];
    public students(string _name, string _surname, string _lastname, int _group, int _age)
    {
        name = _name; surname = _surname; lastname = _lastname; group = _group; age = _age;
        Random N = new Random();
        for (int i = 0; i < 3; i++)
        {
            int r = N.Next(20);
            rating[i] = new int[r];
            for (int j = 0; j < r; j++)
            {
                rating[i][j] = N.Next(11);
            }
        }
    }
    public void setball(int a, int subj) // a- ocenka
    {
        int k=rating[subj].Length;
        int []temp=new int[k];
        for (int i = 0; i < k; i++)
        {
            temp[i] = rating[subj][i];  //скопировали строку(оценки предмета)
        }
        rating[subj] = new int[k + 1];
        for (int i = 0; i < k; i++)
        {
            rating[subj][i]=temp[i];
        }
        rating[subj][k] = a;
    }
    void printsubj(int subj)
    {
       // Console.WriteLine("{0} {1} {2} {3}",name,surname,lastname,age;....
    }
    
}
namespace ArrayFunctions
{
    class Program
    {
        static void TestArr()
        {
            int[] one = { 5, 7, 9 };
            int[,] two = { { 1, 1, 1 }, { 1, 1, 1 }, {1, 1, 1} };
            foreach(int i in two)
            {
                
            }
        }
        static void Main(string[] args)
        {
            students first = new students("BYGA-BYGA","ICE","AGE",03,1300);
            first.setball(10,2);
        }
    }
}

/*26.09.2015 4лекция
 * строки тип StringBuilder
   StringBuilder такую строку изменить можно, не создавая дополнительной копии но мало возможностей. можно преобразовывать строки в строки stringbuilder и наоборот
     В отличие от строк типо string , строки типа stringbuilder являються изменяемыми но имеют меньшее количество возможностей по работе со строками
     Строки типа string при создании выделяют столько памяти сколько необходимо для хранения строки
     Строки типа stringbuilder выделяют изначально память в 16символов а если строка хангимает больше места то размер удваиваеться
 * для создания строки тпа stringbuilder используют следующий синтаксис:
     StringBuilder hello = new StringBuilder("...",емкость строки);
 * строка типа StringBuilder имею два свойства: Length() и Capacity() емкость
     Length() показывает длину строки находящуюся  в данный момент
     Capacity() максимальная длина строки которая может поместиться в выделенную для обьекта память
     По умолчанию для пустой строки емкость устанавливаеться в 16символов
 * Основные методы класса StringBuilder: 
    .Append() добовляет строку к текущей строке
    .AppendFormat() добовляет форматированную строку к текущей строке
    .Insert() вставляет подстроку в строку
    .Remove() удаляет символ из текущей строки
    .Replace()
    .ToString() строку типа StringBuilder можно перевести в строку типа string      sring s=str.ToString()
 * 
 * 
 * 
 * #Классы
     инкапсуляция 
     полиморфизм
     наследование
    [<атрибуты>][<спецификаторы>] class <имя класса>
    { 
        тело класса
    }
    
    class UserInfo
    {
    поля класса
    public string Name, Family, Adress;
    public byte Age;
    
     метод, выводящий в консоль контактную информацию
    public void writeInConsoleInfo(string name,string faamily,string adress,byte age)
    {
    Console.WriteLine("имя: {0}\nФамилия: {1}\nМестонахождение: {2}\nВозраст:{3}\n", name, family, adress, age);
    }
    
    * Object
    при копировании переменных происходит перенос значений а при копировании обьектов они будут укзазывать на одну и ту же область памяти;
    UserInfo myInfo = new UserInfo();
        //  строки данных: значимые и ссылочные
    
         != инициализаторы обьектов
    инициализаторы обьектов предоставляют способ создания обьектоа и инициализации его полей и свойств
    используеться вызов обычного конструктора
    auto myCar = new autoCar { marka = "Renault", year = 2004 };
    
     * Поля(данные члены)
    все поля в классе инициализируете нулями
    поля класса - переменные описанные в классе
    по умолчанию переменные класса считаються закрытыми (private)
    [<атрибуты>][<спецификаторы>] <тип> <имя> [=<начальное значение>];
    
    * Методы(функции члены)
    Если метод ничего не возвращает то тип возвращаемого значение void и return не пишеться
    спецификаторы
    В предеах одного класса сигнатуры методов не должны повторяться
    Фактическиен параметры являються локальными по отношению к методу и уничтожаються после выхода из метода
    спецификаторы: модификаторы доступа, virtual,sealed,static,ovveride, ,extern
    Передача аргументов в метод по ссылке и по значению:
        при классической передаче аргументов метод используеться передача по значению, тоесть переданные аргументы копируються и становяться локальными по отношению к методам.Если из метода необходимо вернуть более одного значения то в такой метод необходимо передовать аргументы по ссылке.Для передачи по ссылке используеться два модификатора ref и out. Модификатор ref и out Должны указываться как при передаче аргументом так и в списке параметров метода
        вызов F(ref x);
        метод F(out int x);
        переменные передаваемые в метод с модификатором ref должны быть обязательно проинициализированы до передачи.
        переменные с модификатором out могут не иметь инициализации, но внутри метода должны быть обязательно проинициализированы
        В методе параметр out считаеться непроинициализированным
    Модификатор Params
        ключевое слово params позволяет передавать методу переменное количество аргументов одного типа ввиде единственного логического параметра
        В качестве аргумента в метод с модицификтором params может быть передан как отдельный массив, так и множество ОДНОТИПНЫХ элементов перечисленных через запятую
        Если метод принимает несколько параметров одним из которых являеться параметр с _parasm то параметр с _params должен идти в списке параметров последним
        В списке параметров метода может присутствовать только один модификатор с параметров params 
        int [] mas
        вызов 1: F(mas);
              2: F(11,2,3,9);
        обьявление: F(params int[]mas){
        }
______________________________________________________________________________________ 
 
 02.03.2015
    * Необязательные и именованные аргументы
    Необязательные аргументы необходимы для того чтобы использовать по умолчанию значения для некоторых параметров метода.Необязательные аргументы указываються в конце списка параметров через знак равно и присвоение значения по умолчаию.
    static int mySum(int a,int b=5,int c=10)
 * {
 * ....
 * }
 * ....
 * int sum=mySum(a,5)
     Именованные аргументы предназначены для передачи в метод в любой последовательности. При передаче необходимо указать имя параметра, двоеточие и его значение.
 * int sum=mySum(c:3,a:3,b:3)
 
    Конструктор
    Конструктор это метод класса предназначенный для инициализации обьекта при созданиикоторый имеет такое же имя как имя класса ничего не возвращает может принимать неограниченное число параметров. Чаще всего используеться со спецификатором доступа public
    Каждый класс снабжаеться конструктором по умолчанию, тоесть без параметра.Такое конструктор можно переопределить
    Point obj=new Point();
  !! При создании конструктора с параметрами конструктор без параметров(который по умолчанию) затираеться поэтому при создании пользовательских типо необходимо пересоздавать конструктор без параметров
 
    Финализатор(деструктор)
    деструктор это метод который вызываеться автоматическим сборщиком мусора перед удалением обьекта из памяти. Деструктор имеет такое же имя как и имя класса ничего не возрващает и ничего не принимает,перед ним используеться знак ~.
    
    This ключевое слово
    Обеспечивает доступ к текущему обьекту. 
    Использование this: 1) для решения неоднозначности контекста    2) Сцепление конструкторов  Сцепление конструкторов используеться когда имееться класс определяющий несколько конструкторов и в каждом из конструкторов необходимо делать однотипные проверки на инициализацию полей, поэтому для предотвращения избыточной проверки один конструктор может вызывать другой. очередность вызова конструктора в цепочке:
        K1(параметр):this(пар1,пар2){тело K1;}   
        K2(пар1,пар2){тело K2;}
    
    Статические элементы класса поля и методы
    статический элемент класса используеться на уровне класса независимо от обьектов этого класса. статические элементы класса обьявляються с помощью ключевого слова static.
    1) статические поля(типо глобальные пля)    все обьекты класса совместно используют статическую переменную. Для доступа к статической переменной Имя_класса.Имя_переменной .
    Class Planet
    {
    private static int Count;
    public Planet()
        {
        Count++;
        }
    }
    2)статические методы 
    используються на уровне класса и вызываються через имя класса.  статические методы могут обращаться только к статическим переменным и методам данного класса.
    в статическом методе не может использоваться ссылка this.   
    3) статические конструкторы
    статический конструктор используеться для инициализации компонентов применяемых ко всему классу. Статический конструктор вызываеться автоматически при первом обращении к имени класса.
    4) статические классы
    статический класс должен содержать только статические члены. обьект статического класса создать нельзя. статические классы используються в основном для хранения совокупности связанных друг с другом статических методов.
    
  * Частичные типы
    Если необходимо разбить класс на разные файлы в рамках одного пространства имен то перед слово класс пишеться слово partial.
    
 !тема    * Исключительные ситуации
    SystemException     ApplicationException
    try{
    <operator1>
    ...
    }
    catch([<тип исключения> [<имя>]]) {
        <operator1>
    ....
    };
    finally
    {
    <operator1>
    ...
    }
    Исключительные ситуации в С# представлен классом exception и его производными. каждый класс описывает конкретную исключительную ситуацию. 
    В блок finally помещаеться код который будет выполнен вне зависимости от того была ли сгенерирована исключительная ситуация.
    Чаще используеться для освобождения различных ресурсов. порядок обработки исключений:
    1) вход в блок try
    2) если исключительная ситуация не возникла то переход к блоку finally а если его нет то переходи к инструкции следующим за последним блоком catch.
    3) если ситуация возникла в блоке try то пееход к соответствующему блоку catch. если в catch нету выхода из метода то далее переход к инструкции после всех блоков catch (либо к finally).
    4) при наличии блока finally его выполнение и переход к инструкции после finally а далее к инструкции после блока finally.
        Исключения могут быть сгенерированы внутри метода который был вызван из блока try. 
        если после блока try используеться несколько блоков catch то каждый отдельный блок должен выполнять обработку определенной исключительной ситуации. блок catch должен иметь определенный тип исключения. блок catch без параметров являеться универсальным и срабатывает для всех типов ошибок и ставиться последним, так как поиск соответствующего блока обработки осуществляеться по очередно.
     
        ! вложенные блоки try и catch.  
            Один try блок можно вложить в другой. Исключения сгенерированное во ввнутреннем try блоке и не перехваченное внутренним catch блоком передаеться во внещний try блок. Вложенность try блоков чаще всего используеться для обработки различных категорий ошибок. во внутреннем блоке помещяються менее опасные, во внешнем - более опасные.
    
03.03.2015  
    Генерирование исключений вручную
    throw - инструкция используеться для того тчобы сгенерировать исключения вручную. После слова throw указываем ключе слово new который создает обьект определенный исключительной ситуации
    try{
        console.write("..");
        throw new FormatException();
    }
    catch(FormatException){
    ...
    }
        class SomException:Exception
        {   public override string Message
            {   get
                {
                    return "some exception";
                }
            }
        }
    Для создания собственных исключений необходимо создать новый класс унаследовать его от класса exception и необходимо переопределить соответствующие свойства и методы. Для генерации пользовательского исключения пользуемся throw
    
    Повторное генерирование исключений:
    Исключения перехваченное одной catch инструкцией можно перегенерировать чтобы обеспечить возможность его перехвата другой внешней catch инструкцией. для этого используеться слово throw без параметра. При повторном генерировании исключения оно не будет повторно перехватываться той же catch инструкцией а передаеться следующей catch инструкции. //выходим на внешний блок try-catch
    
    Свойства и методы классов исключительной ситуации.
    Console.Writeline("свойство message" +exc.Message);
    exc.Message -выводит строку с описанием причины ошибки
    exc.StackTrace -выводит строку со стеком вызоввов приведших к возникновении исключения
    exc.TargetSite -возвращает имя метода сгенерировавшее исключение
   !! для использования данных своств необходимо в параметре блока catch указывать в параметре блока catch имя исключения но и имя обьекта
    
  Применение конструкции checked и unchecked
    эти блоки используються для генерации исключения при возникновении переполнения. эти инструкции исподьзуються в двух формах:
    1) checked(выражение)
       unchecked(выражение)
    2) checked{
            инструкции.}
        unchecked {}
    
        byte a=127,b=127,result;
        try{
            result=checked((byte)(a*b));
            ConsoleWriteLine(result);}
        catch{
            console.writeline(exc.Message);}
    
   Пространство имен
        пространство имен это некая область обьявления данных, которая обеспечивает логическую взимосвязь типов.
        1) пространства имен могут быть вложены в друг друга. в таком случае для доступа к внутреннему классу необходимо перечислить всеп имена пространст имен начиная с внешнего черех точку.
        2) в рамках одного проекта может существовать несколько пространств имен.
        если в одном файле существует два пространства имен то области их видимости не пересекаються, для того чтобы обратиться из одного пространства имен к элементам второго пространства имен необходимо писать полный путь к элементам.
        если два простраства имен куазанные в операторах using содержат тип с одинаковым именем, то необходимо использовать полную форму имени.
       Одно простраство имен может быть разбито на части в рамках одного файла.
       using может применяться не только для подключения простраства имен но и для создания псевдонимов пространства имен.
        using A=AAA;                ///namespace AAA{ }
            A::Incrementor
        
*/